

Date conventions: the frontend should always handle and give to the backend datatime objects (or Timestamps)
DF convention : either the columns have a fixed name, of they are identified by row/column. Right now, backend is a bit strange for that reason.

#PandasSuck : the Timestamps only go from the year 1677 to the year 2262, so changing the spin box boundaries will make the cleanup window crash.

For dates:
    -For raw measures, the format can be anything (I as a programmer still need to know what the convention is).
    -Convert it into YYYY/MM/DD HH:MM:SS This is how it is stored in the database.
    -To access these dates, simply use datetime object. For matplotlib date format, there is a function (matplotib.dates.date) which takes a datetime object and returns an matplotib date object.
CONCLUSION: Always use datetime objects in the program. In database, always store strings in format YYYY/MM/DD HH:MM:SS



TODO:
- 2 types of thermo depths: the real one, and the depth of the cell containing the thermometers. They are distinct!

Heatmap/ quantile: only the direct model is computed, nothing else! So nothing else is stored



import pandas as pd
from pyheatmy import *
from numpy import isnan
from datetime import datetime

temp = pd.read_csv("point035_T_measures.csv")
press = pd.read_csv("point035_P_measures.csv")
truetemp = []
truepress = []
for elem in temp.values.tolist():
    if not (isnan(elem[1]) or isnan(elem[2]) or isnan(elem[3]) or isnan(elem[4])):
        first_elem = datetime.strptime(elem[0], "%m/%d/%y %H:%M:%S %p")
        bis = [first_elem] + [elem[1:]]
        truetemp.append(bis)

for elem in press.values.tolist():
    if not (isnan(elem[1]) or isnan(elem[2])):
        first_elem = datetime.strptime(elem[0], "%m/%d/%y %H:%M:%S %p")
        bis = [first_elem] + [elem[1:]]
        truepress.append(bis)

truetemp = truetemp[1:1000]
truepress = truepress[1:1000]

col_dict = {
	        "river_bed" : 1,
            "depth_sensors" : [0.20,0.4,0.6,1],
	        "offset" : 0,
            "dH_measures" : truepress,
	        "T_measures" : truetemp,
            "sigma_meas_P" : 0,
            "sigma_meas_T" : 0,
            }
a = Column.from_dict(col_dict)
b = Column.from_dict(col_dict)

laye = layersListCreator([["Couche1",1,3,4,5,6]])
a.compute_solve_transi(laye, 10)

priors = {
        "moinslog10K": ((1, 2), 0.01),
        "n": ((0.1, 0.2), 0.01),
        "lambda_s": ((1, 10), 0.01),
        "rhos_cs": ((1, 10), 0.01) }

b.compute_mcmc(10, [["Layer 1", 1, priors]], 10, [0.05,0.5,0.95])