When creating a QSQlQuery object, we always give a connection. For now, the app only handles one connection; when creating an instance of the QSQlQuery, if no connection is specified, then the default one is used. Since the only connection object created is the one in MainWindow, there is in theory no need to put QSQlQuery(con): we could simply say QSQlQuery(). However, if one day we wish the app to handle more than one connection, it will be much simpler to adapt the code, as we will just have to change the "con" object given to the different classes (Lab, Study...)

When creating a QSQlQuery object with a string (ie doing q =QSQlQuery("Select...")),  then the query is instantly executed. We wish to make a difference between the query in itself (the string) and the query object. Therefore, all the functions beginning with build_ return a QSQlQuery which has not been yet executed. It is up to the user to execute them at the appropriate moment. In other words, the build_ functions focus only on creating SQL-correct messages (especially important for difficult query such as in widgetpoint.py) and returning them as a QSQlQuery object, but they are not in charge of executing them, binding values...

When using placeholders (and using bindValue), the convention is that placeholders have the same name as the field in the database.

The config.txt file is created when the user wishes the patht to the database be remembered. It consists in just a line with the absolute path to the database, and is placed next to main.py

DER_IHM.sql contains all the queries (in SQL language) required to recreate the database. It has been generated with the export function of Sqlite Studio.

MoloTreeViewModel and MoloQtList are meant to work with object having at least the unique field or attribute "name". In Molonaviz, the objects used are "Containers" which only purpose is to store different fields, much like a SQL table. 

In the code, Point refers to SamplingPoint. This is because the Point table is a dummy table, used only for computations: it doesn't have any physical meaning. A SamplingPoint (in the code, a Point) corresponds to a physical implantation of different sensors giving readings.

Better laboratory import and point import -> generate CSV in another window

/!\ /!\ /!\ Requires python 3.10 for type hints /!\ /!\ /!\
/!\ /!\ /!\ Not compatible with Python older than 3. exec was a reserveed keyword, so all QT code requiring to execute something (app.exec, dialog.exec, Query.exec...) used an underscore. The functions exec and exec were the same. In Python >3 exec is no longer reserved, and in PyQT6, exec disappears entirely. So, use exec and not exec /!\ /!\ /!\

For dates:
    -For raw measures, the format can be anything (I as a programmer still need to know what the convention is).
    -Convert it into YYYY/MM/DD HH:MM:SS This is how it is stored in the database.
    -To access these dates, simply use datetime object. For matplotlib date format, there is a function (matplotib.dates.date) which takes a datetime object and returns an matplotib date object.
CONCLUSION: Always use datetime objects in the program. In database, always store strings in format YYYY/MM/DD HH:MM:SS


Known bugs:
-Immediately after a computation, they will not appear. Instead, one must close the app and reopen it. This should be fixed when making a difference between backend and frontend.
-When importing a lab, some messages may appear such as "The thermometers have been added to the database", despite it not being the case
- build_data_queries first query is super ugly, and so are other queries ( = SELECT ...)
-Subwindows do not fill up the zone.
-When opening a new point, respect the rule to display subwindows (tabbed, cascade...)
-The C++ file which writes sensor data to csv take dates in the format YYYY:MM:DD:HH:MM:SS (and sampling time in format HH:MM:SS) but writes on the CSV file dates in format YYYY/MM/DD HH:MM:SS
-The pressure matplotib view is now inconsistant: if raw_data then it corresponds to a voltage, and if not raw_data it corresponds to a pressure (m) 
-Sometimes, cleanup may return a pandas dataframe with NaN in charge diff. This was "patched" so that only non-Nan values are put in the database, it is an ugly patch. Cleanup needs to be redone.


Warning: Discrepancy
-The values in the Layer table correspond to the bottom of the layer. The values in Depth correspond to the middle of the cells.
- There is a performance discrepancy when putting results in the dabatase. Here is what is happening:
    -the computations return arrays where each column correspond to a date and each line a Depth
    -Overall, there are more dates than there are dates: there can be thousands of dates but probably no more than a hundred depths. Therefore, if we have to query the dates or the depths thousands of time, we prefer to query the depths: less entries = faster tree research
    -Python is row major, so iterating over a column costs more than iterating over a row as memory isn't contiguous
 So the issue is that either Python will slow us dows because of the row major convention, or SQL will slow us down by doing queries over a table with many entries.

Warning: Duplicate
-Compute and WidgetPoint for cleaned measures
-In Compute, saveLayers and saveLayersAndParams are duplicates
-saveMCMCResults and saveDirectResults are almost copies, except for the method called (get_temps_solve or get_temps_MCMC)

TODO:
- REWORK POINT/SAMPLINGPOINT INTERACTION
-Tooltips! Especially compute window
-What should I do with the default script, currently called sample_text.txt? Where to put it? Default value when creating a point -> when creating a Database, it should be in the Script folder
-Reorganise the folders for all the dialogs
-Date management when importing raw data
-Make the database insensitive to the name of the points/studies (ie 2 points, pressure sensors... may have the same name)
-In Cleanup: translate panda headers in english, and also put capital letters!
-In the pressure sensors/shafts.csv files: less precision for floats? Right now, we have floats with a precision of more thant 10 digits...
-Where to put unique constraints?
-Schemes -> Diagrams?
-QSqlDatabasePrivate::addDatabase: duplicate connection name 'qt_sql_default_connection', old connection removed. This happens because of utils.utils createDatabaseDirectory function, which creates a QT QDatabase object: we then open the connection, and QT doesn't like having two default connections with same name. Needs investigating.
-More robust imports of Lab when informations are missing.
-Creating and opening a study: do not close window if something went wrong (ie wrong study name, empty lab name...) -> Create a FilterComboBox widget?
-Add a simple dialog which can send QDialog::Accept or QDialog::Reject (confirmation dialog)
-Update requirements
-Distinction Point/SamplingPoint + seperate backend/frontend

query.prepare(f"""
    INSERT INTO CleanedMeasures (
        Date,
        TempBed,
        Temp1,
        Temp2,
        Temp3,
        Temp4,
        Pressure,
        PointKey)
    VALUES (:Date, :TempBed, :Temp1, :Temp2, :Temp3, :Temp4, :Pressure, 1)
""")

con.transaction()
for i in range(1):
            q.bindValue(":Date", rng.randint(1,2000))
            q.bindValue(":TempBed", rng.random())
            q.bindValue(":Temp1", rng.random())
            q.bindValue(":Temp2", rng.random())
            q.bindValue(":Temp3", rng.random())
            q.bindValue(":Temp4", rng.random())
            q.bindValue(":Pressure",rng.random())
            print(q.exec())
con.commit()

query.prepare(f"""
    INSERT INTO Date (
        Date)
    VALUES (:Date)
""")