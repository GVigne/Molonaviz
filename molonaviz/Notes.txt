When creating a QSQlQuery object, we always give a connection. For now, the app only handles one connection; when creating an instance of the QSQlQuery, if no connection is specified, then the default one is used. Since the only connection object created is the one in MainWindow, there is in theory no need to put QSQlQuery(con): we could simply say QSQlQuery(). However, if one day we wish the app to handle more than one connection, it will be much simpler to adapt the code, as we will just have to change the "con" object given to the different classes (Lab, Study...)

When creating a QSQlQuery object with a string (ie doing q =QSQlQuery("Select...")),  then the query is instantly executed. We wish to make a difference between the query in itself (the string) and the query object. Therefore, all the functions beginning with build_ return a QSQlQuery which has not been yet executed. It is up to the user to execute them at the appropriate moment. In other words, the build_ functions focus only on creating SQL-correct messages (especially important for difficult query such as in widgetpoint.py) and returning them as a QSQlQuery object, but they are not in charge of executing them, binding values...

The config.txt file is created when the user wishes the path to the database be remembered. It consists in just a line with the absolute path to the database, and is placed next to main.py

DER_IHM.sql contains all the queries (in SQL language) required to recreate the database. It has been generated with the export function of Sqlite Studio.

Studies and laboratories must have unique names for now (ie there is a UNIQUE constraint in the database).

MoloTreeViewModel and MoloQtList are meant to work with object having at least the unique field or attribute "name". In Molonaviz, the objects used are "Containers" which only purpose is to store different fields, much like a SQL table.

/!\ /!\ /!\ Requires python 3.10 for type hints /!\ /!\ /!\
/!\ /!\ /!\ Not compatible with Python older than 3. exec was a reserveed keyword, so all QT code requiring to execute something (app.exec, dialog.exec, Query.exec...) used an underscore. The functions exec and exec were the same. In Python >3 exec is no longer reserved, and in PyQT6, exec disappears entirely. So, use exec and not exec /!\ /!\ /!\

Date conventions: the frontend should always handle and give to the backend datatime objects (or Timestamps)
DF convention : either the columns have a fixed name, of they are identified by row/column. Right now, backend is a bit strange for that reason.

#PandasSuck : the Timestamps only go from the year 1677 to the year 2262, so changing the spin box boundaries will make the cleanup window crash.

For dates:
    -For raw measures, the format can be anything (I as a programmer still need to know what the convention is).
    -Convert it into YYYY/MM/DD HH:MM:SS This is how it is stored in the database.
    -To access these dates, simply use datetime object. For matplotlib date format, there is a function (matplotib.dates.date) which takes a datetime object and returns an matplotib date object.
CONCLUSION: Always use datetime objects in the program. In database, always store strings in format YYYY/MM/DD HH:MM:SS


Known bugs:
-Compute sometimes fail after computations, with error saying directmodel must first be launched before getting data.
-The C++ file which writes sensor data to csv take dates in the format YYYY:MM:DD:HH:MM:SS (and sampling time in format HH:MM:SS) but writes on the CSV file dates in format YYYY/MM/DD HH:MM:SS
-When changing database, since the con is closed and config.txt removed BEFORE opening the "Select database dialog", if the user quits this dialog, then the action is not canceled as it should be.


Warning: Discrepancy
-The values in the Layer table correspond to the bottom of the layer. The values in Depth correspond to the middle of the cells.
- There is a performance discrepancy when putting results in the dabatase. Here is what is happening:
    -the computations return arrays where each column correspond to a date and each line a Depth
    -Overall, there are more dates than there are dates: there can be thousands of dates but probably no more than a hundred depths. Therefore, if we have to query the dates or the depths thousands of time, we prefer to query the depths: less entries = faster tree research
    -Python is row major, so iterating over a column costs more than iterating over a row as memory isn't contiguous
 So the issue is that either Python will slow us dows because of the row major convention, or SQL will slow us down by doing queries over a table with many entries.

Warning: Duplicate
-In Compute, saveLayers and saveLayersAndParams are duplicates
-saveMCMCResults and saveDirectResults are almost copies, except for the method called (get_temps_solve or get_temps_MCMC)
-In samplingPointViewer, the functions to make coordinate the splitters (have them move together) -> do a custom widget

TODO:
-Problem with threads? when launching multiple computations one after the other -> the app freezes.
-What should I do with the default script, currently called sample_text.txt? Where to put it? Default value when creating a point -> when creating a Database, it should be in the Script folder
-Date management when importing raw data
-QSqlDatabasePrivate::addDatabase: duplicate connection name 'qt_sql_default_connection', old connection removed. This happens because of utils.utils createDatabaseDirectory function, which creates a QT QDatabase object: we then open the connection, and QT doesn't like having two default connections with same name. Needs investigating.
- 2 types of thermo depths: the real one, and the depth of the cell containing the thermometers. They are distinct!
- Fix bug where base params are not displayed properly.

Camel case for frontend.
Heatmap/ quantile: only the direct model is computed, nothing else! So nothing else is stored

