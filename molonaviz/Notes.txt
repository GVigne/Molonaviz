When creating a QSQlQuery object, we always give a connection. For now, the app only handles one connection; when creating an instance of the QSQlQuery, if no connection is specified, then the default one is used. Since the only connection object created is the one in MainWindow, there is in theory no need to put QSQlQuery(con): we could simply say QSQlQuery(). However, if one day we wish the app to handle more than one connection, it will be much simpler to adapt the code, as we will just have to change the "con" object given to the different classes (Lab, Study...)

When creating a QSQlQuery object with a string (ie doing q =QSQlQuery("Select...")),  then the query is instantly executed. We wish to make a difference between the query in itself (the string) and the query object. Therefore, all the functions beginning with build_ return a QSQlQuery which has not been yet executed. It is up to the user to execute them at the appropriate moment. In other words, the build_ functions focus only on creating SQL-correct messages (especially important for difficult query such as in widgetpoint.py) and returning them as a QSQlQuery object, but they are not in charge of executing them, binding values...

The config.txt file is created when the user wishes the path to the database be remembered. It consists in just a line with the absolute path to the database, and is placed next to main.py

DER_IHM.sql contains all the queries (in SQL language) required to recreate the database. It has been generated with the export function of Sqlite Studio.

/!\ /!\ /!\ Requires python 3.10 for type hints /!\ /!\ /!\
/!\ /!\ /!\ Not compatible with Python older than 3. exec was a reserveed keyword, so all QT code requiring to execute something (app.exec, dialog.exec, Query.exec...) used an underscore. The functions exec and exec were the same. In Python >3 exec is no longer reserved, and in PyQT6, exec disappears entirely. So, use exec and not exec /!\ /!\ /!\

Date conventions: the frontend should always handle and give to the backend datatime objects (or Timestamps)
DF convention : either the columns have a fixed name, of they are identified by row/column. Right now, backend is a bit strange for that reason.

#PandasSuck : the Timestamps only go from the year 1677 to the year 2262, so changing the spin box boundaries will make the cleanup window crash.

For dates:
    -For raw measures, the format can be anything (I as a programmer still need to know what the convention is).
    -Convert it into YYYY/MM/DD HH:MM:SS This is how it is stored in the database.
    -To access these dates, simply use datetime object. For matplotlib date format, there is a function (matplotib.dates.date) which takes a datetime object and returns an matplotib date object.
CONCLUSION: Always use datetime objects in the program. In database, always store strings in format YYYY/MM/DD HH:MM:SS


Warning: Discrepancy
-The values in the Layer table correspond to the bottom of the layer. The values in Depth correspond to the middle of the cells.


TODO:
- 2 types of thermo depths: the real one, and the depth of the cell containing the thermometers. They are distinct!

Heatmap/ quantile: only the direct model is computed, nothing else! So nothing else is stored



import pandas as pd
from pyheatmy import *
from numpy import isnan
from datetime import datetime

temp = pd.read_csv("point035_T_measures.csv")
press = pd.read_csv("point035_P_measures.csv")
truetemp = []
truepress = []
for elem in temp.values.tolist():
    if not (isnan(elem[1]) or isnan(elem[2]) or isnan(elem[3]) or isnan(elem[4])):
        first_elem = datetime.strptime(elem[0], "%m/%d/%y %H:%M:%S %p")
        bis = [first_elem] + [elem[1:]]
        truetemp.append(bis)

for elem in press.values.tolist():
    if not (isnan(elem[1]) or isnan(elem[2])):
        first_elem = datetime.strptime(elem[0], "%m/%d/%y %H:%M:%S %p")
        bis = [first_elem] + [elem[1:]]
        truepress.append(bis)

truetemp = truetemp[1:1000]
truepress = truepress[1:1000]

col_dict = {
	        "river_bed" : 1,
            "depth_sensors" : [0.20,0.4,0.6,1],
	        "offset" : 0,
            "dH_measures" : truepress,
	        "T_measures" : truetemp,
            "sigma_meas_P" : 0,
            "sigma_meas_T" : 0,
            }
a = Column.from_dict(col_dict)
b = Column.from_dict(col_dict)

laye = layersListCreator([["Couche1",1,3,4,5,6]])
a.compute_solve_transi(laye, 10)

priors = {
        "moinslog10K": ((1, 2), 0.01),
        "n": ((0.1, 0.2), 0.01),
        "lambda_s": ((1, 10), 0.01),
        "rhos_cs": ((1, 10), 0.01) }

b.compute_mcmc(10, [["Layer 1", 1, priors]], 10, [0.05,0.5,0.95])