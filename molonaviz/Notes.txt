When creating a QSQlQuery object, we always give a connection. For now, the app only handles one connection; when creating an instance of the QSQlQuery, if no connection is specified, then the default one is used. Since the only connection object created is the one in MainWindow, there is in theory no need to put QSQlQuery(con): we could simply say QSQlQuery(). However, if one day we wish the app to handle more than one connection, it will be much simpler to adapt the code, as we will just have to change the "con" object given to the different classes (Lab, Study...)

When creating a QSQlQuery object with a string (ie doing q =QSQlQuery("Select...")),  then the query is instantly executed. We wish to make a difference between the query in itself (the string) and the query object. Therefore, all the functions beginning with build_ return a QSQlQuery which has not been yet executed. It is up to the user to execute them at the appropriate moment. In other words, the build_ functions focus only on creating SQL-correct messages (especially important for difficult query such as in widgetpoint.py) and returning them as a QSQlQuery object, but they are not in charge of executing them, binding values...

When using placeholders (and using bindValue), the convention is that placeholders have the same name as the field in the database.

The config.txt file is created when the user wishes the patht to the database be remembered. It consists in just a line with the absolute path to the database, and is placed next to main.py

DER_IHM.sql contains all the queries (in SQL language) required to recreate the database. It has been generated with the export function of Sqlite Studio.

Studies and laboratories must have unique names for now (ie there is a UNIQUE constraint in the database).

MoloTreeViewModel and MoloQtList are meant to work with object having at least the unique field or attribute "name". In Molonaviz, the objects used are "Containers" which only purpose is to store different fields, much like a SQL table. 

In the code, Point refers to SamplingPoint. This is because the Point table is a dummy table, used only for computations: it doesn't have any physical meaning. A SamplingPoint (in the code, a Point) corresponds to a physical implantation of different sensors giving readings.

Better laboratory import and point import -> generate CSV in another window

/!\ /!\ /!\ Requires python 3.10 for type hints /!\ /!\ /!\
/!\ /!\ /!\ Not compatible with Python older than 3. exec was a reserveed keyword, so all QT code requiring to execute something (app.exec, dialog.exec, Query.exec...) used an underscore. The functions exec and exec were the same. In Python >3 exec is no longer reserved, and in PyQT6, exec disappears entirely. So, use exec and not exec /!\ /!\ /!\

Date conventions: the frontend should always handle and give to the backend datatime objects (or Timestamps)
DF convention : either the columns have a fixed name, of they are identified by row/column. Right now, backend is a bit strange for that reason.

#PandasSuck : the Timestamps only go from the year 1677 to the year 2262, so changing the spin box boundaries will make the cleanup window crash.

For dates:
    -For raw measures, the format can be anything (I as a programmer still need to know what the convention is).
    -Convert it into YYYY/MM/DD HH:MM:SS This is how it is stored in the database.
    -To access these dates, simply use datetime object. For matplotlib date format, there is a function (matplotib.dates.date) which takes a datetime object and returns an matplotib date object.
CONCLUSION: Always use datetime objects in the program. In database, always store strings in format YYYY/MM/DD HH:MM:SS


Known bugs:
-When importing a lab, some messages may appear such as "The thermometers have been added to the database", despite it not being the case
-Subwindows do not fill up the zone.
-When opening a new point, respect the rule to display subwindows (tabbed, cascade...)
-The C++ file which writes sensor data to csv take dates in the format YYYY:MM:DD:HH:MM:SS (and sampling time in format HH:MM:SS) but writes on the CSV file dates in format YYYY/MM/DD HH:MM:SS
-The pressure matplotib view is now inconsistant: if raw_data then it corresponds to a voltage, and if not raw_data it corresponds to a pressure (m) 
-Sometimes, cleanup may return a pandas dataframe with NaN in charge diff. This was "patched" so that only non-Nan values are put in the database, it is an ugly patch. Cleanup needs to be redone.
-Open a point. A subwindow is put in the MDI area using addSubWindow: it doesn't have a scroll bar and fits on the screen. Now change to cascade (or tile view) and back again to subwindow view (the default view). This time, there is a scrollbar, so it's a big ugly: its probably because when using addSubWindow, a resize happens somewhere in some manner. I tested with setFocus but that didn't work.
-When changing database, since the con is closed and config.txt removed BEFORE opening the "Select database dialog", if the user quits this dialog, then the action is not canceled as it should be.
-Compute sometimes fail after computations, with error saying directmodel must first be launched before getting data.


Warning: Discrepancy
-The values in the Layer table correspond to the bottom of the layer. The values in Depth correspond to the middle of the cells.
- There is a performance discrepancy when putting results in the dabatase. Here is what is happening:
    -the computations return arrays where each column correspond to a date and each line a Depth
    -Overall, there are more dates than there are dates: there can be thousands of dates but probably no more than a hundred depths. Therefore, if we have to query the dates or the depths thousands of time, we prefer to query the depths: less entries = faster tree research
    -Python is row major, so iterating over a column costs more than iterating over a row as memory isn't contiguous
 So the issue is that either Python will slow us dows because of the row major convention, or SQL will slow us down by doing queries over a table with many entries.

Warning: Duplicate
-Compute and WidgetPoint for cleaned measures
-In Compute, saveLayers and saveLayersAndParams are duplicates
-saveMCMCResults and saveDirectResults are almost copies, except for the method called (get_temps_solve or get_temps_MCMC)

TODO:
-Fix segfault when quitting the app while computations are being made.
-Problem with threads? when launching multiple computations one after the other -> the app freezes.
-In InsertCleanedMeasures, remove isnan
-Create a custom iterable object from a QSQLquery which does not require to create a list. This is easy: just reimplement __iter__
-Reduce the number of dialogs. Many dialogs are just confirmation and/or a combo box with different fields.
-Turn the info model into a true MoloModel
-Tooltips! Especially compute window
-What should I do with the default script, currently called sample_text.txt? Where to put it? Default value when creating a point -> when creating a Database, it should be in the Script folder
-Date management when importing raw data
-Make the database insensitive to the name of the points/studies (ie 2 points, pressure sensors... may have the same name)
-In Cleanup: translate panda headers in english, and also put capital letters!
-Where to put unique constraints?
-Where to put null constraints? Many foreign keys do not have such constraints, and this can be a big problem. When importing a lab, if a thermometer is invalid, it will not be added to the database. Should the pressure sensors and shafts linked to this thermometer be added with an empty field or simply not added? It'd say not added -> just have to change the database.
-QSqlDatabasePrivate::addDatabase: duplicate connection name 'qt_sql_default_connection', old connection removed. This happens because of utils.utils createDatabaseDirectory function, which creates a QT QDatabase object: we then open the connection, and QT doesn't like having two default connections with same name. Needs investigating.
-More robust imports of Lab when informations are missing.
-Creating and opening a study: do not close window if something went wrong (ie wrong study name, empty lab name...) -> Create a FilterComboBox widget?
- allCleanedMeasures : convert dates to Timestamps?