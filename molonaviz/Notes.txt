When creating a QSQlQuery object, we always give a connection. For now, the app only handles one connection; when creating an instance of the QSQlQuery, if no connection is specified, then the default one is used. Since the only connection object created is the one in MainWindow, there is in theory no need to put QSQlQuery(con): we could simply say QSQlQuery(). However, if one day we wish the app to handle more than one connection, it will be much simpler to adapt the code, as we will just have to change the "con" object given to the different classes (Lab, Study...)

When creating a QSQlQuery object with a string (ie doing q =QSQlQuery("Select...")),  then the query is instantly executed. We wish to make a difference between the query in itself (the string) and the query object. Therefore, all the functions beginning with build_ return a QSQlQuery which has not been yet executed. It is up to the user to execute them at the appropriate moment. In other words, the build_ functions focus only on creating SQL-correct messages (especially important for difficult query such as in widgetpoint.py) and returning them as a QSQlQuery object, but they are not in charge of executing them, binding values...

When using placeholders (and using bindValue), the convention is that placeholders have the same name as the field in the database.

The config.txt file is created when the user wishes the patht to the database be remembered. It consists in just a line with the absolute path to the database, and is placed next to main.py

DER_IHM.sql contains all the queries (in SQL language) required to recreate the database. It has been generated with the export function of Sqlite Studio.

MoloTreeViewModel and MoloQtList are meant to work with object having at least the unique field or attribute "name". In Molonaviz, the objects used are "Containers" which only purpose is to store different fields, much like a SQL table. 

In the code, Point refers to SamplingPoint. This is because the Point table is a dummy table, used only for computations: it doesn't have any physical meaning. A SamplingPoint (in the code, a Point) corresponds to a physical implantation of different sensors giving readings.

Better laboratory import and point import -> generate CSV in another window

/!\ /!\ /!\ Requires python 3.10 for type hints /!\ /!\ /!\
/!\ /!\ /!\ Not compatible with Python older than 3. exec was a reserveed keyword, so all QT code requiring to execute something (app.exec, dialog.exec, Query.exec...) used an underscore. The functions exec and exec were the same. In Python >3 exec is no longer reserved, and in PyQT6, exec disappears entirely. So, use exec and not exec /!\ /!\ /!\

For dates:
    -For raw measures, the format can be anything (I as a programmer still need to know what the convention is).
    -Convert it into YYYY/MM/DD HH:MM:SS This is how it is stored in the database.
    -To access these dates, simply use datetime object. For matplotlib date format, there is a function (matplotib.dates.date) which takes a datetime object and returns an matplotib date object.
CONCLUSION: Always use datetime objects in the program. In database, always store strings in format YYYY/MM/DD HH:MM:SS


Known bugs:
-When importing a lab, some messages may appear such as "The thermometers have been added to the database", despite it not being the case
- build_data_queries first query is super ugly, and so are other queries ( = SELECT ...)
-Subwindows do not fill up the zone.
-When opening a new point, respect the rule to display subwindows (tabbed, cascade...)
-The C++ file which writes sensor data to csv take dates in the format YYYY:MM:DD:HH:MM:SS (and sampling time in format HH:MM:SS) but writes on the CSV file dates in format YYYY/MM/DD HH:MM:SS

Warning: Duplicate
-Compute and WidgetPoint for cleaned measures

TODO:
- REWORK POINT/SAMPLINGPOINT INTERACTION
-Tooltips! Especially compute window
-What should I do with the default script, currently called sample_text.txt? Where to put it? Default value when creating a point -> when creating a Database, it should be in the Script folder
-Reorganise the folders for all the dialogs
-Date management when importing raw data
-Make the database insensitive to the name of the points/studies (ie 2 points, pressure sensors... may have the same name)
-In Cleanup: translate panda headers in english, and also put capital letters!
-In the pressure sensors/shafts.csv files: less precision for floats? Right now, we have floats with a precision of more thant 10 digits...
-Where to put unique constraints?
-Schemes -> Diagrams?
-More robust imports of Lab when informations are missing.
-Creating and opening a study: do not close window if something went wrong (ie wrong study name, empty lab name...) -> Create a FilterComboBox widget?
-Add a simple dialog which can send QDialog::Accept or QDialog::Reject (confirmation dialog)


query.prepare(f"""
    INSERT INTO CleanedMeasures (
        Date,
        TempBed,
        Temp1,
        Temp2,
        Temp3,
        Temp4,
        Pressure,
        PointKey)
    VALUES (:Date, :TempBed, :Temp1, :Temp2, :Temp3, :Temp4, :Pressure, 1)
""")

con.transaction()
for i in range(1):
            q.bindValue(":Date", rng.randint(1,2000))
            q.bindValue(":TempBed", rng.random())
            q.bindValue(":Temp1", rng.random())
            q.bindValue(":Temp2", rng.random())
            q.bindValue(":Temp3", rng.random())
            q.bindValue(":Temp4", rng.random())
            q.bindValue(":Pressure",rng.random())
            print(q.exec())
con.commit()

query.prepare(f"""
    INSERT INTO Date (
        Date)
    VALUES (:Date)
""")